SELECT company_name
FROM suppliers
WHERE country IN (SELECT DISTINCT country
				  FROM customers);
				  
SELECT DISTINCT suppliers.company_name
FROM suppliers
JOIN customers USING(country);

SELECT category_name, SUM(units_in_stock)
FROM products
INNER JOIN  categories USING(category_id)
GROUP BY category_name
ORDER BY SUM(units_in_stock) DESC
LIMIT (SELECT MIN(product_id) + 4 FROM products);

SELECT *
FROM person;

INSERT INTO person
VALUES ('4', 'ASFF', 'SADFSDF');

DELETE FROM person
WHERE first_name = 'ASFF';

UPDATE person
SET person_id = 1
WHERE person_id = 4;

SELECT *
FROM person
WHERE person_id IN (SELECT employee_id 
				   FROM employee);
				   
SELECT *
FROM book
WHERE book_id IN (SELECT person_id
				 FROM person);

SELECT *
FROM book
WHERE book_id BETWEEN 2 AND 4;

SELECT first_name AS F_name, last_name AS Surname
FROM person;

SELECT book_id AS b_id, CONCAT(title, ', ', isbn) AS together
FROM book;

-- CREATING TABLES
CREATE TABLE donators (
	donator_id Integer,
	first_name varchar(255) NOT NULL,
	last_name varchar(255) NOT NULL,
	username varchar(255) NOT NULL,
	age Integer NOT NULL,
	country varchar(255) NOT NULL
);

CREATE TABLE donates (
	donate_id Integer,
	donator_id Integer NOT NULL,
	price Integer NOT NULL,
	donate_date date NOT NULL,
	ship_id Integer NOT NULL
);

CREATE TABLE donate_receives (
	receive_id Integer,
	donator_id Integer NOT NULL,
	donate_id Integer NOT NULL,
	receive_date date NOT NULL,
	country varchar(255) NOT NULL
);

INSERT INTO donators
VALUES 
	(1, 'Artem', 'Petrenko', 'Griezman', 14, 'Ukraine'),
	(2, 'Sasha', 'Sidorenko', 'Zra4Ok', 16, 'Ukraine'),
	(3, 'John', 'Lemon', 'Jlemon', 20, 'USA'),
	(4, 'Simon', 'Rose', 'Rosetta', 30, 'USA'),
	(5, 'Evelyn', 'Pank', 'Chunk', 13, 'Canada');

INSERT INTO donates
VALUES (1, 5, 500, '03-08-2020', 10),
	   (2, 3, 1000, '03-22-2020', 9),
	   (3, 1, 2500, '03-31-2020', 8),
	   (4, 2, 10, '06-02-2020', 7),
	   (5, 4, 90, '07-17-2020', 6),
	   (6, 3, 75, '08-10-2020', 5),
	   (7, 1, 800, '09-30-2020', 4),
	   (8, 1, 60, '10-20-2020', 3),
	   (9, 5, 30, '11-03-2020', 2),
	   (10, 2, 45, '12-31-2020', 1);

INSERT INTO donate_receives
VALUES (1, 2, 10, '01-02-2021', 'Canada'),
	   (2, 5, 9, '12-15-2020', 'USA'),
	   (3, 1, 8, '11-04-2021', 'Ukraine'),
	   (4, 1, 7, '10-08-2021', 'Ukraine'),
	   (5, 3, 6, '09-17-2021', 'USA'),
	   (6, 4, 5, '08-22-2021', 'USA'),
	   (7, 2, 4, '07-25-2021', 'Ukraine'),
	   (8, 1, 3, '06-07-2021', 'Ukraine'),
	   (9, 3, 2, '05-03-2021', 'USA'),
	   (10, 5, 1, '04-02-2021', 'Canada');

SELECT donators.first_name, donators.username,
		donators.age, donates.price, donates.donate_date
FROM donators
JOIN donates ON donators.donator_id = donates.donator_id;

SELECT *
FROM person;

--ALTER TABLE person
--ADD email varchar(64);

--ALTER TABLE person
--DROP COLUMN email;

--ALTER TABLE person
--ADD age int CHECK (age >= 18);

INSERT INTO person (person_id, first_name, last_name, age)
VALUES (5, 'fdghd', 'sdf', 18);


--ALTER TABLE person
--ALTER email SET DEFAULT 'SADFSFD';

--ALTER TABLE persons
--ADD incrementing int 1 SERIAL 1;

CREATE PROCEDURE test_procedure
AS $$
BEGIN
	SELECT * FROM person
END; $$
SELECT *
FROM products;

SELECT product_name, units_in_stock
FROM products
WHERE units_in_stock < ALL (
	SELECT AVG(quantity)
	FROM order_details
	GROUP BY product_id
)
ORDER BY units_in_stock DESC;


SELECT *
FROM orders;

SELECT customer_id, SUM(freight) AS freight_sum
FROM orders
INNER JOIN (SELECT customer_id, AVG(freight) AS freight_avg
		   FROM orders
		   GROUP BY customer_id) oa
USING(customer_id)
WHERE freight > freight_avg AND shipped_date BETWEEN '1996-07-16' AND '1996-07-31'
GROUP BY customer_id
ORDER BY freight_sum;

SELECT *
FROM orders;

SELECT customer_id, ship_country, order_price
FROM orders
JOIN (SELECT order_id, SUM(unit_price * quantity - unit_price * quantity * discount) AS order_price
	  FROM order_details
	  GROUP BY order_id) AS od
USING(order_id)
WHERE order_date >= '1997-09-01' AND ship_country IN ('Argentina', 'Bolivia', 'Brazil', 'Chile', 'Colombia', 'Ecuador', 'Guyana', 'Paraguay', 'Peru', 'Suriname', 'Uruguay', 'Venezuela')
ORDER BY freight DESC
LIMIT 3;

SELECT *
FROM products;

SELECT product_name
FROM products
WHERE product_id = ANY (
	SELECT product_id FROM order_details WHERE quantity = 10
);

CREATE TABLE faculty
(
	faculty_id serial,
	faculty_name varchar
);

INSERT INTO faculty (faculty_name)
VALUES ('faculty 1'),
	   ('faculty 2'),
	   ('faculty 3');
	   
SELECT *
FROM faculty;

TRUNCATE TABLE faculty RESTART IDENTITY;

--CREATE TABLE teacher
(
	teacher_id serial,
	first_name varchar,
	last_name varchar,
	birthday date,
	phone varchar,
	title varchar
);

ALTER TABLE teacher
ADD COLUMN middle_name varchar;

ALTER TABLE teacher
DROP COLUMN middle_name;

ALTER TABLE teacher
RENAME birthday TO birth_date;

ALTER TABLE teacher
ALTER COLUMN phone SET DATA TYPE varchar(32);

SELECT *
FROM teacher;

--CREATE TABLE exam 
(
	exam_id serial,
	exam_name varchar(256),
	exam_date date
);

INSERT INTO exam (exam_name, exam_date)
VALUES ('test 1', '2020-09-01'),
		('test 2', '2021-01-15'),
		('test 3', '2021-03-31');

SELECT *
FROM exam;

TRUNCATE TABLE exam CONTINUE IDENTITY;

TRUNCATE TABLE exam RESTART IDENTITY;
--DROP TABLE IF EXISTS chair;

--CREATE TABLE chair (
	chair_id serial UNIQUE NOT NULL,
	chair_name varchar,
	dean varchar
	
	-- SECOND VARIANT IS: CONSTRAINT PK_chair_pkey PRIMARY KEY(chair_id)
);
-- PRIMARY KEY may be only one in all table but UNIQUE NOT NULL can be even in each column
INSERT INTO chair
VALUES (NULL, 'name3', 'dean3');

SELECT * FROM chair;

SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'chair'
	AND table_schema = 'public'
	AND column_name = 'chair_id';

ALTER TABLE chair
DROP CONSTRAINT chair_pkey;

ALTER TABLE chair
ADD PRIMARY KEY(chair_id);

-- DROP TABLE book;

CREATE TABLE publisher
(
	publisher_id int,
	publisher_name varchar(128) NOT NULL,
	address text,
	
	CONSTRAINT PK_publisher_id PRIMARY KEY(publisher_id)
);

CREATE TABLE book
(
	book_id int,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id),
	CONSTRAINT FK_book_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id)
);

INSERT INTO publisher
VALUES 
(1, 'Everyman''s Library', 'NY'),
(2, 'Oxford University Press', 'NY'),
(3, 'Grand Central Publishing', 'Washington'),
(4, 'Simon & Schuster', 'Chicago');

INSERT INTO book
VALUES
(1, 'The Diary of a Young Girl', '0199545566', 10);

SELECT * FROM book

TRUNCATE TABLE book

ALTER TABLE book
ADD CONSTRAINT FK_book_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id);

ALTER TABLE book
DROP CONSTRAINT FK_book_publisher;

DROP TABLE IF EXISTS book; 

CREATE TABLE book
(
	book_id int,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

ALTER TABLE book
ADD COLUMN price decimal CONSTRAINT CHK_book_price CHECK (price >= 0);

INSERT INTO book
VALUES
(1, 'title', 'isbn', 1, 0);

CREATE TABLE customer
(
	customer_id serial,
	full_name text,
	status char DEFAULT 'r',
	
	CONSTRAINT PK_customer_customer_id PRIMARY KEY(customer_id),
	CONSTRAINT CHK_customer_status CHECK (status = 'r' OR status = 'p')
);

INSERT INTO customer (full_name)
VALUES
('name');

SELECT * FROM customer;

-- DROP TABLE customer;

ALTER TABLE customer
ALTER COLUMN status DROP DEFAULT;

ALTER TABLE customer
ALTER COLUMN status SET DEFAULT 'r';

CREATE SEQUENCE seq1;

SELECT nextval('seq1');
SELECT currval('seq1');
SELECT lastval();

SELECT setval('seq1', 16, true);
SELECT currval('seq1');
SELECT nextval('seq1');

SELECT setval('seq1', 16, false);
SELECT currval('seq1');
SELECT nextval('seq1');

CREATE SEQUENCE IF NOT EXISTS seq2 INCREMENT 16;
SELECT nextval('seq2');

CREATE SEQUENCE IF NOT EXISTS seq3
INCREMENT 16
MINVALUE 0
MAXVALUE 128
START WITH 0;

SELECT nextval('seq3');

ALTER SEQUENCE seq3 RENAME TO seq4;
ALTER SEQUENCE seq4 RESTART WITH 16;

SELECT nextval('seq4');

DROP SEQUENCE seq4;

DROP TABLE IF EXISTS book;

CREATE TABLE book
(
	book_id int NOT NULL,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

SELECT * FROM book;

CREATE SEQUENCE IF NOT EXISTS book_book_id_seq
START WITH 1 OWNED BY book.book_id;

INSERT INTO book (title, isbn, publisher_id)
--OVERRIDING SYSTEM VALUE
VALUES ('title', 'isbn', 1);

ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('book_book_id_seq');

SELECT * FROM book;

CREATE TABLE book
(
	book_id serial NOT NULL,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

CREATE TABLE book
(
	book_id int GENERATED ALWAYS AS IDENTITY (START WITH 10 INCREMENT BY 2) NOT NULL, -- BETTER THAN serial 
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

TRUNCATE TABLE book CONTINUE IDENTITY;

INSERT INTO author
VALUES (10, 'Joh Silver', 4.5);

SELECT * FROM author;

INSERT INTO author (author_id, full_name)
VALUES 
(12, 'Name 1'),
(13, 'Name 2'),
(14, 'Name 3');

SELECT *
INTO best_authors
FROM author
WHERE rating >= 4.5;

SELECT *
FROM best_authors;

INSERT INTO best_authors
SELECT *
FROM author
WHERE rating < 4.5;

SELECT * FROM author;

UPDATE author
SET full_name = 'Alias', rating = 5
WHERE author_id = 1;

DELETE FROM author
WHERE rating < 4.5;

DELETE FROM author;

TRUNCATE TABLE author; -- works faster and better than DELETE

DROP TABLE book;

CREATE TABLE public.book
(
	book_id serial,
	title text NOT NULL,
	isbn character varying(32) NOT NULL,
	publisher_id integer NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

INSERT INTO book (title, isbn, publisher_id)
VALUES ('title', 'isbn', 3)
RETURNING *;

INSERT INTO author
VALUES (3, 'full_name', 4)
RETURNING *;

UPDATE author
SET full_name = 'Walter', rating = 5
WHERE author_id = 1
RETURNING author_id;


DELETE FROM author
WHERE rating = 5
RETURNING *;

SELECT * FROM author;

--DROP TABLE IF EXISTS exam;

CREATE TABLE exam 
(
	exam_id int GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT BY 1), UNIQUE, NOT NULL,
	exam_name varchar(32),
	exam_date date
);

ALTER TABLE exam
DELETE CONSTRAINT

-- something

DROP TABLE IF EXISTS person;

DROP TABLE IF EXISTS passport;

CREATE TABLE person 
(
	person_id int, PRIMARY KEY,
	first_name varchar,
	last_name varchar
);

CREATE TABLE passport
(
	passport_id int PRIMARY KEY,
	serial_number int NOT NULL,
	register varchar(32),
	person_id int FOREIGN KEY
);

ALTER TABLE book
ADD COLUMN weight int CHECK weight > 0 AND weight < 100;

DROP TABLE student;

CREATE TABLE student
(
	student_id int GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT BY 1),
	full_name text,
	course int DEFAULT 1
);

INSERT INTO student (full_name)
VALUES ('NAME')
RETURNING *;

SELECT * FROM student;

 CREATE VIEW products_suppliers_categories AS
 SELECT product_name, quantity_per_unit, unit_price, units_in_stock,
 	company_name, contact_name, phone, category_name, description
FROM products
JOIN suppliers USING(supplier_id)
JOIN categories USING(category_id);

SELECT *
FROM products_suppliers_categories
WHERE unit_price > 20;

DROP VIEW IF EXISTS products_suppliers_categories;

SELECT * FROM orders;

CREATE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 50;

SELECT *
FROM heavy_orders
ORDER BY freight DESC;

CREATE OR REPLACE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 100;

CREATE OR REPLACE VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, discontinued
	   company_name, contact_name, phone, country, category_name, description
FROM products
JOIN suppliers USING(supplier_id)
JOIN categories USING(category_id);  -- impossible because you can't add columns

SELECT *
FROM products_suppliers_categories
WHERE discontinued = 1;

ALTER VIEW products_suppliers_categories RENAME TO psc_old;

SELECT MAX(order_id)
FROM  orders;

INSERT INTO heavy_orders
VALUES (11078, 'VINET', 5, '2019-12-10', '2019-12-15', '2019-12-14', 1, 120,
	   'hANARI cARNES', 'Rua do Paco', 'Bern', null, 3012, 'Switzerland');

SELECT *
FROM heavy_orders
ORDER BY order_id DESC;

SELECT MIN(freight)
FROM orders;

DELETE FROM heavy_orders
WHERE freight < 0.05;

DELETE FROM heavy_orders
WHERE freight < 100.25;

DELETE FROM order_details
WHERE order_id = 10854;

SELECT *
FROM heavy_orders
ORDER BY freight;

INSERT INTO heavy_orders
VALUES(11901, 'FOLIG', 1, '2000-01-01', '2000-01-05', '2000-01-04', 1, 80, 'Folies gourmandes', '184, chaussee de Tournai',
	  'Lille', NULL, 59000, 'FRANCE');

SELECT *
FROM orders
WHERE order_id = 11900;

CREATE OR REPLACE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 100
WITH LOCAL CHECK OPTION;
 -- 1
CREATE VIEW many_dates AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	company_name, contact_name, phone, last_name, first_name, title
FROM orders
INNER JOIN customers USING(customer_id)
INNER JOIN employees USING(employee_id);

SELECT *
FROM many_dates
WHERE order_date > '1997-01-01';
-- 2
SELECT *
FROM customers;

CREATE VIEW dates_ships AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	ship_country, company_name, contact_name, phone, last_name,
	first_name, title
FROM orders
JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

SELECT *
FROM dates_ships;

CREATE OR REPLACE VIEW new_dates_ships AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	company_name, ship_country, customers.postal_code, reports_to,
	contact_name, phone, last_name,
	first_name, title
FROM orders
JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

ALTER VIEW dates_ships RENAME TO new_dates_ships;

SELECT *
FROM new_dates_ships;

CREATE VIEW updated_dates AS
SELECT order_date, required_date, shipped_date, ship_postal_code, 
	ship_country, company_name,  customers.postal_code, reports_to,
	contact_name, phone, last_name,
	first_name, title
FROM orders
INNER JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

SELECT *
FROM updated_dates
ORDER BY ship_country;

DROP VIEW updated_dates;
-- 3
CREATE OR REPLACE VIEW active AS
SELECT *
FROM products
WHERE discontinued = 0
WITH LOCAL CHECK OPTION; -- FOR MAKING INSERT WHERE discontinued is 1 impossible

SELECT *
FROM active;

INSERT INTO active
VALUES (81, 'SADF', 20, 6, '43 SMTH', 3.5, 4, 3, 2, 1);

SELECT MAX(product_id)
FROM active;

SELECT product_name, unit_price, units_in_stock,
	CASE WHEN units_in_stock >= 100 THEN 'lost of'
		WHEN units_in_stock >= 50 AND units_in_stock < 100 THEN 'average'
		WHEN units_in_stock < 50 THEN 'low number'
		ELSE 'unknown'
	END AS amount
FROM products
ORDER BY units_in_stock DESC;

SELECT order_id, order_date,
	CASE WHEN date_part('month', order_date) BETWEEN 3 AND 5 THEN 'spring'
		WHEN date_part('month', order_date) BETWEEN 6 AND 8 THEN 'summer'
		WHEN date_part('month', order_date) BETWEEN 9 AND 11 THEN 'autumn'
		ELSE 'winter'
	END AS season
FROM orders;

SELECT product_name, unit_price,
	CASE WHEN unit_price >= 30 THEN 'Expensive'
		WHEN unit_price < 30 THEN 'Inexpensive'
		ELSE 'Undetermined'
	END AS price_description
FROM products;

SELECT *
FROM orders
LIMIT 10;

SELECT order_id, order_date, COALESCE(ship_region, 'unknown') AS ship_region
FROM orders
LIMIT 10;

SELECT *
FROM employees;

SELECT last_name, first_name, COALESCE(region, 'N/A') AS region
FROM employees;

-- COALESCE WE USE IF WE HAVE NULL VALUE AND WANT TO CHANGE IT TO SMTH
SELECT *
FROM customers;

SELECT contact_name, COALESCE(NULLIF(city, ' '), 'Unknown') AS city
FROM customers;
-- NULLIF works with COALESCE TO MAKE CHANGING ALL VALUES POSSIBLE

insert into customers(customer_id, contact_name, city, country, company_name)
values 
('AAAAA', 'Alfred Mann', NULL, 'USA', 'fake_company'),
('BBBBB', 'Alfred Mann', NULL, 'Austria','fake_company');

-- 1
SELECT contact_name, city, country
FROM customers
ORDER BY contact_name ,
(
	CASE WHEN city IS NULL THEN country
		ELSE city
	END
);

SELECT *
FROM products;

-- 2
SELECT product_name, unit_price,
	CASE WHEN unit_price >= 100 THEN 'too expensive'
		WHEN unit_price >= 50 AND unit_price < 100 THEN 'average'
		WHEN unit_price < 50 THEN 'low price'
	END AS general_price
FROM products;

SELECT *
FROM employees;
--3
SELECT contact_name,
	CASE WHEN order_id IS NULL THEN 'no orders'
		ELSE order_id::text
	END AS order_id_or_no
FROM customers
LEFT JOIN orders USING(customer_id)
--WHERE orders.order_id IS NULL;

--4
SELECT first_name, last_name, 
	COALESCE(NULLIF(title, 'Sales Representative'), 'Sales Stuff') AS title
FROM employees;

SELECT *
FROM customers;

SELECT *
INTO tmp_customers
FROM customers;

SELECT *
FROM tmp_customers;

UPDATE tmp_customers
SET region = 'unknown'
WHERE region IS NULL;

CREATE OR REPLACE FUNCTION fix_customer_region() RETURNS void AS $$
	UPDATE tmp_customers
	SET region = 'unknown'
	WHERE region IS NULL
$$ LANGUAGE SQL;

SELECT fix_customer_region();

CREATE OR REPLACE FUNCTION get_total_number_of_goods() RETURNS bigint AS $$
	SELECT SUM(units_in_stock) AS total_goods
	FROM products
$$ language SQL;

SELECT get_total_number_of_goods();

CREATE OR REPLACE FUNCTION get_avg_price() RETURNS float8 AS $$
	SELECT AVG(unit_price)
	FROM products
$$ LANGUAGE SQL;

SELECT get_avg_price() AS avg_price;

CREATE OR REPLACE FUNCTION get_product_price_by_name(prod_name varchar) RETURNS real AS $$
	SELECT unit_price -- it is possible to type (IN prod_name varchar) but it is same
	FROM products
	WHERE product_name = prod_name
$$ LANGUAGE SQL;

SELECT get_product_price_by_name('Chocolade') AS price;

SELECT *
FROM products;

CREATE OR REPLACE FUNCTION get_price_boundaries(OUT max_price real, OUT min_price real) AS $$
	SELECT MAX(unit_price), MIN(unit_price)
	FROM products
$$ LANGUAGE SQL;

SELECT get_price_boundaries();
SELECT * FROM get_price_boundaries();

CREATE OR REPLACE FUNCTION get_price_boundaries_by_discontinuity(IN is_discontinued int DEFAULT 1, OUT max_price real, OUT min_price real) AS $$
	SELECT MAX(unit_price), MIN(unit_price)
	FROM products
	WHERE discontinued = is_discontinued
$$ LANGUAGE SQL; -- IN in arguments is not necessary

SELECT get_price_boundaries_by_discontinuity(1);
SELECT * 
FROM get_price_boundaries_by_discontinuity(1);

SELECT get_price_boundaries_by_discontinuity(0);
SELECT * 
FROM get_price_boundaries_by_discontinuity(0);

SELECT get_price_boundaries_by_discontinuity();
SELECT * 
FROM get_price_boundaries_by_discontinuity();

-- HW
-- 1 need a bit change (it also must delete old one)
CREATE OR REPLACE FUNCTION backup() RETURNS void AS $$
	SELECT *
	INTO tmp_customers
	FROM customers
$$ LANGUAGE SQL;

SELECT *
FROM backup();
-- 2
CREATE OR REPLACE FUNCTION average_freight() RETURNS real AS $$
	SELECT AVG(freight)
	FROM orders
$$ LANGUAGE SQL;

SELECT *
FROM average_freight();

SELECT average_freight();
-- 4
CREATE OR REPLACE FUNCTION max_min_salary(IN city varchar(15), OUT max_salary real, OUT min_salary real) AS $$
	SELECT MAX(salary), MIN(salary)
	FROM employees
$$ LANGUAGE SQL;

SELECT *
FROM employees;

SELECT *
FROM max_min_salary;


CREATE OR REPLACE FUNCTION get_average_prices_by_categories()
		RETURNS SETOF double precision AS $$
	SELECT AVG(unit_price)
	FROM products
	GROUP BY category_id
$$ LANGUAGE SQL;

SELECT *
FROM get_average_prices_by_categories() AS average_prices;

CREATE OR REPLACE FUNCTION get_avg_price_by_prod_cats()
		RETURNS SETOF RECORD 
		AS $$
	SELECT SUM(unit_price), AVG(unit_price)
	FROM products
	GROUP BY category_id
	
$$ LANGUAGE SQL;

SELECT sum_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price, avg_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price AS num_of, avg_price AS in_avg
FROM get_avg_price_by_prod_cats();

DROP FUNCTION get_avg_price_by_prod_cats;

SELECT sum_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price, avg_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price AS num_of, avg_price AS in_avg
FROM get_avg_price_by_prod_cats();

SELECT *
FROM get_avg_price_by_prod_cats();

SELECT *
FROM get_avg_price_by_prod_cats() AS (sum_price real, avg_price float8);


CREATE OR REPLACE FUNCTION get_customers_by_country(customer_country varchar)
		RETURNS TABLE(char_code char, company_name varchar) AS $$
	
	SELECT customer_id, company_name
	FROM customers
	WHERE country = customer_country
	
$$ LANGUAGE SQL;

SELECT *
FROM get_customers_by_country('USA');

SELECT company_name 
FROM get_customers_by_country('USA');

SELECT char_code, company_name
FROM get_customers_by_country('USA');

DROP FUNCTION get_customers_by_country;
CREATE OR REPLACE FUNCTION get_customers_by_country(customer_country varchar)
		RETURNS SETOF customers AS $$
	
	-- won't work SELECT customer_id, company_name
	SELECT *
	FROM customers
	WHERE country = customer_country
	
$$ LANGUAGE SQL;

SELECT * FROM get_customers_by_country('USA');
SELECT company_name 
FROM get_customers_by_country('USA');


