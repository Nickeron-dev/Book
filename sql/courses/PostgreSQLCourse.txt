SELECT company_name
FROM suppliers
WHERE country IN (SELECT DISTINCT country
				  FROM customers);
				  
SELECT DISTINCT suppliers.company_name
FROM suppliers
JOIN customers USING(country);

SELECT category_name, SUM(units_in_stock)
FROM products
INNER JOIN  categories USING(category_id)
GROUP BY category_name
ORDER BY SUM(units_in_stock) DESC
LIMIT (SELECT MIN(product_id) + 4 FROM products);

SELECT *
FROM person;

INSERT INTO person
VALUES ('4', 'ASFF', 'SADFSDF');

DELETE FROM person
WHERE first_name = 'ASFF';

UPDATE person
SET person_id = 1
WHERE person_id = 4;

SELECT *
FROM person
WHERE person_id IN (SELECT employee_id 
				   FROM employee);
				   
SELECT *
FROM book
WHERE book_id IN (SELECT person_id
				 FROM person);

SELECT *
FROM book
WHERE book_id BETWEEN 2 AND 4;

SELECT first_name AS F_name, last_name AS Surname
FROM person;

SELECT book_id AS b_id, CONCAT(title, ', ', isbn) AS together
FROM book;

-- CREATING TABLES
CREATE TABLE donators (
	donator_id Integer,
	first_name varchar(255) NOT NULL,
	last_name varchar(255) NOT NULL,
	username varchar(255) NOT NULL,
	age Integer NOT NULL,
	country varchar(255) NOT NULL
);

CREATE TABLE donates (
	donate_id Integer,
	donator_id Integer NOT NULL,
	price Integer NOT NULL,
	donate_date date NOT NULL,
	ship_id Integer NOT NULL
);

CREATE TABLE donate_receives (
	receive_id Integer,
	donator_id Integer NOT NULL,
	donate_id Integer NOT NULL,
	receive_date date NOT NULL,
	country varchar(255) NOT NULL
);

INSERT INTO donators
VALUES 
	(1, 'Artem', 'Petrenko', 'Griezman', 14, 'Ukraine'),
	(2, 'Sasha', 'Sidorenko', 'Zra4Ok', 16, 'Ukraine'),
	(3, 'John', 'Lemon', 'Jlemon', 20, 'USA'),
	(4, 'Simon', 'Rose', 'Rosetta', 30, 'USA'),
	(5, 'Evelyn', 'Pank', 'Chunk', 13, 'Canada');

INSERT INTO donates
VALUES (1, 5, 500, '03-08-2020', 10),
	   (2, 3, 1000, '03-22-2020', 9),
	   (3, 1, 2500, '03-31-2020', 8),
	   (4, 2, 10, '06-02-2020', 7),
	   (5, 4, 90, '07-17-2020', 6),
	   (6, 3, 75, '08-10-2020', 5),
	   (7, 1, 800, '09-30-2020', 4),
	   (8, 1, 60, '10-20-2020', 3),
	   (9, 5, 30, '11-03-2020', 2),
	   (10, 2, 45, '12-31-2020', 1);

INSERT INTO donate_receives
VALUES (1, 2, 10, '01-02-2021', 'Canada'),
	   (2, 5, 9, '12-15-2020', 'USA'),
	   (3, 1, 8, '11-04-2021', 'Ukraine'),
	   (4, 1, 7, '10-08-2021', 'Ukraine'),
	   (5, 3, 6, '09-17-2021', 'USA'),
	   (6, 4, 5, '08-22-2021', 'USA'),
	   (7, 2, 4, '07-25-2021', 'Ukraine'),
	   (8, 1, 3, '06-07-2021', 'Ukraine'),
	   (9, 3, 2, '05-03-2021', 'USA'),
	   (10, 5, 1, '04-02-2021', 'Canada');

SELECT donators.first_name, donators.username,
		donators.age, donates.price, donates.donate_date
FROM donators
JOIN donates ON donators.donator_id = donates.donator_id;

SELECT *
FROM person;

--ALTER TABLE person
--ADD email varchar(64);

--ALTER TABLE person
--DROP COLUMN email;

--ALTER TABLE person
--ADD age int CHECK (age >= 18);

INSERT INTO person (person_id, first_name, last_name, age)
VALUES (5, 'fdghd', 'sdf', 18);


--ALTER TABLE person
--ALTER email SET DEFAULT 'SADFSFD';

--ALTER TABLE persons
--ADD incrementing int 1 SERIAL 1;

CREATE PROCEDURE test_procedure
AS $$
BEGIN
	SELECT * FROM person
END; $$
SELECT *
FROM products;

SELECT product_name, units_in_stock
FROM products
WHERE units_in_stock < ALL (
	SELECT AVG(quantity)
	FROM order_details
	GROUP BY product_id
)
ORDER BY units_in_stock DESC;


SELECT *
FROM orders;

SELECT customer_id, SUM(freight) AS freight_sum
FROM orders
INNER JOIN (SELECT customer_id, AVG(freight) AS freight_avg
		   FROM orders
		   GROUP BY customer_id) oa
USING(customer_id)
WHERE freight > freight_avg AND shipped_date BETWEEN '1996-07-16' AND '1996-07-31'
GROUP BY customer_id
ORDER BY freight_sum;

SELECT *
FROM orders;

SELECT customer_id, ship_country, order_price
FROM orders
JOIN (SELECT order_id, SUM(unit_price * quantity - unit_price * quantity * discount) AS order_price
	  FROM order_details
	  GROUP BY order_id) AS od
USING(order_id)
WHERE order_date >= '1997-09-01' AND ship_country IN ('Argentina', 'Bolivia', 'Brazil', 'Chile', 'Colombia', 'Ecuador', 'Guyana', 'Paraguay', 'Peru', 'Suriname', 'Uruguay', 'Venezuela')
ORDER BY freight DESC
LIMIT 3;

SELECT *
FROM products;

SELECT product_name
FROM products
WHERE product_id = ANY (
	SELECT product_id FROM order_details WHERE quantity = 10
);

CREATE TABLE faculty
(
	faculty_id serial,
	faculty_name varchar
);

INSERT INTO faculty (faculty_name)
VALUES ('faculty 1'),
	   ('faculty 2'),
	   ('faculty 3');
	   
SELECT *
FROM faculty;

TRUNCATE TABLE faculty RESTART IDENTITY;

--CREATE TABLE teacher
(
	teacher_id serial,
	first_name varchar,
	last_name varchar,
	birthday date,
	phone varchar,
	title varchar
);

ALTER TABLE teacher
ADD COLUMN middle_name varchar;

ALTER TABLE teacher
DROP COLUMN middle_name;

ALTER TABLE teacher
RENAME birthday TO birth_date;

ALTER TABLE teacher
ALTER COLUMN phone SET DATA TYPE varchar(32);

SELECT *
FROM teacher;

--CREATE TABLE exam 
(
	exam_id serial,
	exam_name varchar(256),
	exam_date date
);

INSERT INTO exam (exam_name, exam_date)
VALUES ('test 1', '2020-09-01'),
		('test 2', '2021-01-15'),
		('test 3', '2021-03-31');

SELECT *
FROM exam;

TRUNCATE TABLE exam CONTINUE IDENTITY;

TRUNCATE TABLE exam RESTART IDENTITY;
--DROP TABLE IF EXISTS chair;

--CREATE TABLE chair (
	chair_id serial UNIQUE NOT NULL,
	chair_name varchar,
	dean varchar
	
	-- SECOND VARIANT IS: CONSTRAINT PK_chair_pkey PRIMARY KEY(chair_id)
);
-- PRIMARY KEY may be only one in all table but UNIQUE NOT NULL can be even in each column
INSERT INTO chair
VALUES (NULL, 'name3', 'dean3');

SELECT * FROM chair;

SELECT constraint_name
FROM information_schema.key_column_usage
WHERE table_name = 'chair'
	AND table_schema = 'public'
	AND column_name = 'chair_id';

ALTER TABLE chair
DROP CONSTRAINT chair_pkey;

ALTER TABLE chair
ADD PRIMARY KEY(chair_id);

-- DROP TABLE book;

CREATE TABLE publisher
(
	publisher_id int,
	publisher_name varchar(128) NOT NULL,
	address text,
	
	CONSTRAINT PK_publisher_id PRIMARY KEY(publisher_id)
);

CREATE TABLE book
(
	book_id int,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id),
	CONSTRAINT FK_book_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id)
);

INSERT INTO publisher
VALUES 
(1, 'Everyman''s Library', 'NY'),
(2, 'Oxford University Press', 'NY'),
(3, 'Grand Central Publishing', 'Washington'),
(4, 'Simon & Schuster', 'Chicago');

INSERT INTO book
VALUES
(1, 'The Diary of a Young Girl', '0199545566', 10);

SELECT * FROM book

TRUNCATE TABLE book

ALTER TABLE book
ADD CONSTRAINT FK_book_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id);

ALTER TABLE book
DROP CONSTRAINT FK_book_publisher;

DROP TABLE IF EXISTS book; 

CREATE TABLE book
(
	book_id int,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

ALTER TABLE book
ADD COLUMN price decimal CONSTRAINT CHK_book_price CHECK (price >= 0);

INSERT INTO book
VALUES
(1, 'title', 'isbn', 1, 0);

CREATE TABLE customer
(
	customer_id serial,
	full_name text,
	status char DEFAULT 'r',
	
	CONSTRAINT PK_customer_customer_id PRIMARY KEY(customer_id),
	CONSTRAINT CHK_customer_status CHECK (status = 'r' OR status = 'p')
);

INSERT INTO customer (full_name)
VALUES
('name');

SELECT * FROM customer;

-- DROP TABLE customer;

ALTER TABLE customer
ALTER COLUMN status DROP DEFAULT;

ALTER TABLE customer
ALTER COLUMN status SET DEFAULT 'r';

CREATE SEQUENCE seq1;

SELECT nextval('seq1');
SELECT currval('seq1');
SELECT lastval();

SELECT setval('seq1', 16, true);
SELECT currval('seq1');
SELECT nextval('seq1');

SELECT setval('seq1', 16, false);
SELECT currval('seq1');
SELECT nextval('seq1');

CREATE SEQUENCE IF NOT EXISTS seq2 INCREMENT 16;
SELECT nextval('seq2');

CREATE SEQUENCE IF NOT EXISTS seq3
INCREMENT 16
MINVALUE 0
MAXVALUE 128
START WITH 0;

SELECT nextval('seq3');

ALTER SEQUENCE seq3 RENAME TO seq4;
ALTER SEQUENCE seq4 RESTART WITH 16;

SELECT nextval('seq4');

DROP SEQUENCE seq4;

DROP TABLE IF EXISTS book;

CREATE TABLE book
(
	book_id int NOT NULL,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

SELECT * FROM book;

CREATE SEQUENCE IF NOT EXISTS book_book_id_seq
START WITH 1 OWNED BY book.book_id;

INSERT INTO book (title, isbn, publisher_id)
--OVERRIDING SYSTEM VALUE
VALUES ('title', 'isbn', 1);

ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('book_book_id_seq');

SELECT * FROM book;

CREATE TABLE book
(
	book_id serial NOT NULL,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

CREATE TABLE book
(
	book_id int GENERATED ALWAYS AS IDENTITY (START WITH 10 INCREMENT BY 2) NOT NULL, -- BETTER THAN serial 
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

TRUNCATE TABLE book CONTINUE IDENTITY;

INSERT INTO author
VALUES (10, 'Joh Silver', 4.5);

SELECT * FROM author;

INSERT INTO author (author_id, full_name)
VALUES 
(12, 'Name 1'),
(13, 'Name 2'),
(14, 'Name 3');

SELECT *
INTO best_authors
FROM author
WHERE rating >= 4.5;

SELECT *
FROM best_authors;

INSERT INTO best_authors
SELECT *
FROM author
WHERE rating < 4.5;

SELECT * FROM author;

UPDATE author
SET full_name = 'Alias', rating = 5
WHERE author_id = 1;

DELETE FROM author
WHERE rating < 4.5;

DELETE FROM author;

TRUNCATE TABLE author; -- works faster and better than DELETE

DROP TABLE book;

CREATE TABLE public.book
(
	book_id serial,
	title text NOT NULL,
	isbn character varying(32) NOT NULL,
	publisher_id integer NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

INSERT INTO book (title, isbn, publisher_id)
VALUES ('title', 'isbn', 3)
RETURNING *;

INSERT INTO author
VALUES (3, 'full_name', 4)
RETURNING *;

UPDATE author
SET full_name = 'Walter', rating = 5
WHERE author_id = 1
RETURNING author_id;


DELETE FROM author
WHERE rating = 5
RETURNING *;

SELECT * FROM author;

--DROP TABLE IF EXISTS exam;

CREATE TABLE exam 
(
	exam_id int GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT BY 1), UNIQUE, NOT NULL,
	exam_name varchar(32),
	exam_date date
);

ALTER TABLE exam
DELETE CONSTRAINT

-- something

DROP TABLE IF EXISTS person;

DROP TABLE IF EXISTS passport;

CREATE TABLE person 
(
	person_id int, PRIMARY KEY,
	first_name varchar,
	last_name varchar
);

CREATE TABLE passport
(
	passport_id int PRIMARY KEY,
	serial_number int NOT NULL,
	register varchar(32),
	person_id int FOREIGN KEY
);

ALTER TABLE book
ADD COLUMN weight int CHECK weight > 0 AND weight < 100;

DROP TABLE student;

CREATE TABLE student
(
	student_id int GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT BY 1),
	full_name text,
	course int DEFAULT 1
);

INSERT INTO student (full_name)
VALUES ('NAME')
RETURNING *;

SELECT * FROM student;

 CREATE VIEW products_suppliers_categories AS
 SELECT product_name, quantity_per_unit, unit_price, units_in_stock,
 	company_name, contact_name, phone, category_name, description
FROM products
JOIN suppliers USING(supplier_id)
JOIN categories USING(category_id);

SELECT *
FROM products_suppliers_categories
WHERE unit_price > 20;

DROP VIEW IF EXISTS products_suppliers_categories;

SELECT * FROM orders;

CREATE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 50;

SELECT *
FROM heavy_orders
ORDER BY freight DESC;

CREATE OR REPLACE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 100;

CREATE OR REPLACE VIEW products_suppliers_categories AS
SELECT product_name, quantity_per_unit, unit_price, units_in_stock, discontinued
	   company_name, contact_name, phone, country, category_name, description
FROM products
JOIN suppliers USING(supplier_id)
JOIN categories USING(category_id);  -- impossible because you can't add columns

SELECT *
FROM products_suppliers_categories
WHERE discontinued = 1;

ALTER VIEW products_suppliers_categories RENAME TO psc_old;

SELECT MAX(order_id)
FROM  orders;

INSERT INTO heavy_orders
VALUES (11078, 'VINET', 5, '2019-12-10', '2019-12-15', '2019-12-14', 1, 120,
	   'hANARI cARNES', 'Rua do Paco', 'Bern', null, 3012, 'Switzerland');

SELECT *
FROM heavy_orders
ORDER BY order_id DESC;

SELECT MIN(freight)
FROM orders;

DELETE FROM heavy_orders
WHERE freight < 0.05;

DELETE FROM heavy_orders
WHERE freight < 100.25;

DELETE FROM order_details
WHERE order_id = 10854;

SELECT *
FROM heavy_orders
ORDER BY freight;

INSERT INTO heavy_orders
VALUES(11901, 'FOLIG', 1, '2000-01-01', '2000-01-05', '2000-01-04', 1, 80, 'Folies gourmandes', '184, chaussee de Tournai',
	  'Lille', NULL, 59000, 'FRANCE');

SELECT *
FROM orders
WHERE order_id = 11900;

CREATE OR REPLACE VIEW heavy_orders AS
SELECT *
FROM orders
WHERE freight > 100
WITH LOCAL CHECK OPTION;
 -- 1
CREATE VIEW many_dates AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	company_name, contact_name, phone, last_name, first_name, title
FROM orders
INNER JOIN customers USING(customer_id)
INNER JOIN employees USING(employee_id);

SELECT *
FROM many_dates
WHERE order_date > '1997-01-01';
-- 2
SELECT *
FROM customers;

CREATE VIEW dates_ships AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	ship_country, company_name, contact_name, phone, last_name,
	first_name, title
FROM orders
JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

SELECT *
FROM dates_ships;

CREATE OR REPLACE VIEW new_dates_ships AS
SELECT order_date, required_date, shipped_date, ship_postal_code,
	company_name, ship_country, customers.postal_code, reports_to,
	contact_name, phone, last_name,
	first_name, title
FROM orders
JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

ALTER VIEW dates_ships RENAME TO new_dates_ships;

SELECT *
FROM new_dates_ships;

CREATE VIEW updated_dates AS
SELECT order_date, required_date, shipped_date, ship_postal_code, 
	ship_country, company_name,  customers.postal_code, reports_to,
	contact_name, phone, last_name,
	first_name, title
FROM orders
INNER JOIN customers USING(customer_id)
JOIN employees USING(employee_id);

SELECT *
FROM updated_dates
ORDER BY ship_country;

DROP VIEW updated_dates;
-- 3
CREATE OR REPLACE VIEW active AS
SELECT *
FROM products
WHERE discontinued = 0
WITH LOCAL CHECK OPTION; -- FOR MAKING INSERT WHERE discontinued is 1 impossible

SELECT *
FROM active;

INSERT INTO active
VALUES (81, 'SADF', 20, 6, '43 SMTH', 3.5, 4, 3, 2, 1);

SELECT MAX(product_id)
FROM active;

SELECT product_name, unit_price, units_in_stock,
	CASE WHEN units_in_stock >= 100 THEN 'lost of'
		WHEN units_in_stock >= 50 AND units_in_stock < 100 THEN 'average'
		WHEN units_in_stock < 50 THEN 'low number'
		ELSE 'unknown'
	END AS amount
FROM products
ORDER BY units_in_stock DESC;

SELECT order_id, order_date,
	CASE WHEN date_part('month', order_date) BETWEEN 3 AND 5 THEN 'spring'
		WHEN date_part('month', order_date) BETWEEN 6 AND 8 THEN 'summer'
		WHEN date_part('month', order_date) BETWEEN 9 AND 11 THEN 'autumn'
		ELSE 'winter'
	END AS season
FROM orders;

SELECT product_name, unit_price,
	CASE WHEN unit_price >= 30 THEN 'Expensive'
		WHEN unit_price < 30 THEN 'Inexpensive'
		ELSE 'Undetermined'
	END AS price_description
FROM products;

SELECT *
FROM orders
LIMIT 10;

SELECT order_id, order_date, COALESCE(ship_region, 'unknown') AS ship_region
FROM orders
LIMIT 10;

SELECT *
FROM employees;

SELECT last_name, first_name, COALESCE(region, 'N/A') AS region
FROM employees;

-- COALESCE WE USE IF WE HAVE NULL VALUE AND WANT TO CHANGE IT TO SMTH
SELECT *
FROM customers;

SELECT contact_name, COALESCE(NULLIF(city, ' '), 'Unknown') AS city
FROM customers;
-- NULLIF works with COALESCE TO MAKE CHANGING ALL VALUES POSSIBLE

insert into customers(customer_id, contact_name, city, country, company_name)
values 
('AAAAA', 'Alfred Mann', NULL, 'USA', 'fake_company'),
('BBBBB', 'Alfred Mann', NULL, 'Austria','fake_company');

-- 1
SELECT contact_name, city, country
FROM customers
ORDER BY contact_name ,
(
	CASE WHEN city IS NULL THEN country
		ELSE city
	END
);

SELECT *
FROM products;

-- 2
SELECT product_name, unit_price,
	CASE WHEN unit_price >= 100 THEN 'too expensive'
		WHEN unit_price >= 50 AND unit_price < 100 THEN 'average'
		WHEN unit_price < 50 THEN 'low price'
	END AS general_price
FROM products;

SELECT *
FROM employees;
--3
SELECT contact_name,
	CASE WHEN order_id IS NULL THEN 'no orders'
		ELSE order_id::text
	END AS order_id_or_no
FROM customers
LEFT JOIN orders USING(customer_id)
--WHERE orders.order_id IS NULL;

--4
SELECT first_name, last_name, 
	COALESCE(NULLIF(title, 'Sales Representative'), 'Sales Stuff') AS title
FROM employees;

SELECT *
FROM customers;

SELECT *
INTO tmp_customers
FROM customers;

SELECT *
FROM tmp_customers;

UPDATE tmp_customers
SET region = 'unknown'
WHERE region IS NULL;

CREATE OR REPLACE FUNCTION fix_customer_region() RETURNS void AS $$
	UPDATE tmp_customers
	SET region = 'unknown'
	WHERE region IS NULL
$$ LANGUAGE SQL;

SELECT fix_customer_region();

CREATE OR REPLACE FUNCTION get_total_number_of_goods() RETURNS bigint AS $$
	SELECT SUM(units_in_stock) AS total_goods
	FROM products
$$ language SQL;

SELECT get_total_number_of_goods();

CREATE OR REPLACE FUNCTION get_avg_price() RETURNS float8 AS $$
	SELECT AVG(unit_price)
	FROM products
$$ LANGUAGE SQL;

SELECT get_avg_price() AS avg_price;

CREATE OR REPLACE FUNCTION get_product_price_by_name(prod_name varchar) RETURNS real AS $$
	SELECT unit_price -- it is possible to type (IN prod_name varchar) but it is same
	FROM products
	WHERE product_name = prod_name
$$ LANGUAGE SQL;

SELECT get_product_price_by_name('Chocolade') AS price;

SELECT *
FROM products;

CREATE OR REPLACE FUNCTION get_price_boundaries(OUT max_price real, OUT min_price real) AS $$
	SELECT MAX(unit_price), MIN(unit_price)
	FROM products
$$ LANGUAGE SQL;

SELECT get_price_boundaries();
SELECT * FROM get_price_boundaries();

CREATE OR REPLACE FUNCTION get_price_boundaries_by_discontinuity(IN is_discontinued int DEFAULT 1, OUT max_price real, OUT min_price real) AS $$
	SELECT MAX(unit_price), MIN(unit_price)
	FROM products
	WHERE discontinued = is_discontinued
$$ LANGUAGE SQL; -- IN in arguments is not necessary

SELECT get_price_boundaries_by_discontinuity(1);
SELECT * 
FROM get_price_boundaries_by_discontinuity(1);

SELECT get_price_boundaries_by_discontinuity(0);
SELECT * 
FROM get_price_boundaries_by_discontinuity(0);

SELECT get_price_boundaries_by_discontinuity();
SELECT * 
FROM get_price_boundaries_by_discontinuity();

-- HW
-- 1 need a bit change (it also must delete old one)
CREATE OR REPLACE FUNCTION backup() RETURNS void AS $$
	SELECT *
	INTO tmp_customers
	FROM customers
$$ LANGUAGE SQL;

SELECT *
FROM backup();
-- 2
CREATE OR REPLACE FUNCTION average_freight() RETURNS real AS $$
	SELECT AVG(freight)
	FROM orders
$$ LANGUAGE SQL;

SELECT *
FROM average_freight();

SELECT average_freight();
-- 4
CREATE OR REPLACE FUNCTION max_min_salary(IN city varchar(15), OUT max_salary real, OUT min_salary real) AS $$
	SELECT MAX(salary), MIN(salary)
	FROM employees
$$ LANGUAGE SQL;

SELECT *
FROM employees;

SELECT *
FROM max_min_salary;


CREATE OR REPLACE FUNCTION get_average_prices_by_categories()
		RETURNS SETOF double precision AS $$
	SELECT AVG(unit_price)
	FROM products
	GROUP BY category_id
$$ LANGUAGE SQL;

SELECT *
FROM get_average_prices_by_categories() AS average_prices;

CREATE OR REPLACE FUNCTION get_avg_price_by_prod_cats()
		RETURNS SETOF RECORD 
		AS $$
	SELECT SUM(unit_price), AVG(unit_price)
	FROM products
	GROUP BY category_id
	
$$ LANGUAGE SQL;

SELECT sum_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price, avg_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price AS num_of, avg_price AS in_avg
FROM get_avg_price_by_prod_cats();

DROP FUNCTION get_avg_price_by_prod_cats;

SELECT sum_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price, avg_price 
FROM get_avg_price_by_prod_cats();

SELECT sum_price AS num_of, avg_price AS in_avg
FROM get_avg_price_by_prod_cats();

SELECT *
FROM get_avg_price_by_prod_cats();

SELECT *
FROM get_avg_price_by_prod_cats() AS (sum_price real, avg_price float8);


CREATE OR REPLACE FUNCTION get_customers_by_country(customer_country varchar)
		RETURNS TABLE(char_code char, company_name varchar) AS $$
	
	SELECT customer_id, company_name
	FROM customers
	WHERE country = customer_country
	
$$ LANGUAGE SQL;

SELECT *
FROM get_customers_by_country('USA');

SELECT company_name 
FROM get_customers_by_country('USA');

SELECT char_code, company_name
FROM get_customers_by_country('USA');

DROP FUNCTION get_customers_by_country;
CREATE OR REPLACE FUNCTION get_customers_by_country(customer_country varchar)
		RETURNS SETOF customers AS $$
	
	-- won't work SELECT customer_id, company_name
	SELECT *
	FROM customers
	WHERE country = customer_country
	
$$ LANGUAGE SQL;

SELECT * FROM get_customers_by_country('USA');
SELECT company_name 
FROM get_customers_by_country('USA');

CREATE OR REPLACE FUNCTION get_total_number_of_goods() RETURNS bigint AS $$
BEGIN
	RETURN SUM(unit_in_stock)
	FROM products;
END;
$$ LANGUAGE plpgsql

SELECT get_total_number_of_goods();

CREATE OR REPLACE FUNCTION get_max_price_from_discontinued() RETURNS real AS $$
BEGIN
	RETURN MAX(unit_price)
	FROM products
	WHERE discontinued = 1;
END;
$$ LANGUAGE plpgsql;

SELECT get_max_price_from_discontinued();

CREATE OR REPLACE FUNCTION get_price_boundaries(OUT max_price real, OUT min_price real) AS $$
BEGIN
	--max_price := MAX(unit_price) FROM products;
	--min_price := MIN(unit_price) FROM products;
	SELECT MAX(unit_price), MIN(unit_price)
	INTO max_price, min_price
	FROM products;
END;
$$ LANGUAGE plpgsql;

SELECT get_price_boundaries();
SELECT * FROM get_price_boundaries();

CREATE OR REPLACE FUNCTION get_sum(x int, y int, OUT result int) AS $$
BEGIN
	result := x + y; -- same as result = x + y; BUT PEOPLE USE := TO MAKE COMPARISON DIFFERENT FROM CREATING VARIABLES
	RETURN;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_sum(2, 3);

DROP FUNCTION IF EXISTS get_customers_by_country;
CREATE FUNCTION get_customers_by_country(customer_country varchar) RETURNS SETOF customers AS $$
BEGIN
	RETURN QUERY
	SELECT *
	FROM customers
	WHERE country = customer_country;
END;
$$ LANGUAGE plpgsql;

SELECT *
FROM get_customers_by_country('USA');

CREATE FUNCTION get_square(ab real, bc real, ac real) RETURNS real AS $$
DECLARE
	perimeter real;
BEGIN
	perimeter = (ab + bc + ac) / 2;
	RETURN sqrt(perimeter * (perimeter - ab) * (perimeter - bc) * (perimeter - ac));
END;
$$ LANGUAGE plpgsql;

SELECT get_square(6, 6, 6);

CREATE FUNCTION calc_middle_price() RETURNS SETOF products AS $$
DECLARE
	avg_price real;
	low_price real;
	high_price real;
BEGIN
	SELECT AVG(unit_price) INTO avg_price
	FROM products;
	
	low_price = avg_price * 0.75;
	high_price = avg_price * 1.25;
	
	RETURN QUERY
	SELECT * FROM products
	WHERE unit_price BETWEEN low_price AND high_price;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM calc_middle_price();

DROP FUNCTION IF EXISTS convert_temp_to;
CREATE OR REPLACE FUNCTION convert_temp_to(temperature real, to_celsius bool DEFAULT true) RETURNS real AS $$
DECLARE 
	result_temp real;
BEGIN
	IF to_celsius THEN
		result_temp = (5.0 / 9.0) * (temperature - 32);
	ELSE
		result_temp = (9 * temperature + (32 * 5)) / 5.0;
	END IF;
	
	RETURN result_temp;
END;
$$ LANGUAGE plpgsql;

SELECT convert_temp_to(80);
SELECT convert_temp_to(26.66666, false);

CREATE FUNCTION get_season(month_number int) RETURNS text AS $$
DECLARE 
	season text;
BEGIN
	IF month_number BETWEEN 3 AND 5 THEN
		season = 'Spring';
	ELSEIF month_number BETWEEN 6 AND 8 THEN
		season = 'Summer';
	ELSEIF month_number BETWEEN 9 AND 11 THEN
		season = 'Autumn';
	ELSE
		season = 'Winter';
	END IF;
	
	RETURN season;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION fib(n int) RETURNS int AS $$
DECLARE
	counter int = 0;
	i int = 0;
	j int = 1;
BEGIN
	IF n < 1 THEN
		RETURN 0;
	END IF;
	
	WHILE counter <= n
	LOOP
		counter = counter + 1;
		SELECT j, i + j INTO i, j;
	END LOOP;
	
	RETURN i;
END;
$$ LANGUAGE plpgsql;


SELECT fib(5);

CREATE OR REPLACE FUNCTION fib(n int) RETURNS int AS $$
DECLARE
	counter int = 0;
	i int = 0;
	j int = 1;
BEGIN
	IF n < 1 THEN
		RETURN 0;
	END IF;
	

	LOOP
		EXIT WHEN counter = n + 1;
		counter = counter + 1;
		SELECT j, i + j INTO i, j;
	END LOOP;
	
	RETURN i;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
	FOR counter IN 1..5
	LOOP
		RAISE NOTICE 'Counter: %', counter;
	END LOOP;
END $$;

DO $$
BEGIN
	FOR counter IN REVERSE 5..1
	LOOP
		RAISE NOTICE 'Counter: %', counter;
	END LOOP;
END $$;

DO $$
BEGIN
	FOR counter IN 1..11 BY 2
	LOOP
		RAISE NOTICE 'Counter: %', counter;
	END LOOP;
END $$;

CREATE FUNCTION return_ints() RETURNS SETOF int AS $$
BEGIN
	RETURN NEXT 1;
	RETURN NEXT 2;
	RETURN NEXT 3;
	-- RETURN; NOT NECESSARY
END;
$$ LANGUAGE plpgsql;

SELECT *
FROM return_ints();

CREATE FUNCTION after_christmas_sale() RETURNS SETOF products AS $$
DECLARE 
	product record;
BEGIN
	FOR product IN SELECT * FROM products
	LOOP
		IF product.category_id IN(1, 4, 8) THEN
			product.unit_price = product.unit_price * 0.8;
		ELSEIF product.category_id IN(2, 3, 7) THEN
			product.unit_price = product.unit_price * 0.75;
		ELSE
			product.unit_price = product.unit_price * 1.1;
		END IF;
		RETURN NEXT product;
	END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM after_christmas_sale();

ALTER TABLE employees
ADD COLUMN salary numeric(12,2);

UPDATE employees
SET salary=64.47
WHERE employee_id=1;

UPDATE employees
SET salary=52.42
WHERE employee_id=2;

UPDATE employees
SET salary=78.47
WHERE employee_id=3;

UPDATE employees
SET salary=62.95
WHERE employee_id=4;

UPDATE employees
SET salary=55.56
WHERE employee_id=5;

UPDATE employees
SET salary=54.92
WHERE employee_id=6;

UPDATE employees
SET salary=64.35
WHERE employee_id=7;

UPDATE employees
SET salary=75.60
WHERE employee_id=8;

UPDATE employees
SET salary=0.00
WHERE employee_id=9;
SELECT employee_id, salary FROM employees
order by employee_id

-- HW
-- 1 need a bit change (it also must delete old one)
CREATE OR REPLACE FUNCTION backup() RETURNS void AS $$
	DROP TABLE IF EXISTS tmp_customers;
	--SELECT *
	--INTO tmp_customers
	--FROM customers
	
	CREATE TABLE tmp_customers AS
	SELECT * FROM customers;
$$ LANGUAGE SQL;

SELECT *
FROM backup();
-- 2
CREATE OR REPLACE FUNCTION average_freight() RETURNS real AS $$
	SELECT AVG(freight)
	FROM orders
$$ LANGUAGE SQL;

SELECT *
FROM average_freight();

SELECT average_freight();

-- 3
CREATE OR REPLACE FUNCTION random_between(low int, high int) RETURNS int AS $$
BEGIN 
	RETURN floor(random() * (high - low + 1) + low);
END
$$ LANGUAGE plpgsql;

SELECT random_between(1, 8)
FROM generate_series(1, 10)



-- 4
DROP FUNCTION max_min_salary;
CREATE OR REPLACE FUNCTION max_min_salary(emp_city varchar, out min_salary numeric, out max_salary numeric) AS $$
		SELECT MAX(salary), MIN(salary)
		FROM employees
		WHERE city = emp_city
$$ LANGUAGE SQL;

SELECT *
FROM employees;

SELECT *
FROM max_min_salary('London');

-- 5
DROP FUNCTION IF EXISTS salary_changer;
CREATE OR REPLACE FUNCTION salary_changer(upper_boundary numeric DEFAULT 70, correction_rate numeric DEFAULT 0.15) 
RETURNS TABLE(last_name text, first_name text, title text, salary numeric) AS 
$$
	UPDATE employees
	SET salary = salary + (salary * correction_rate)
	WHERE salary <= upper_boundary
	RETURNING last_name, first_name, title, salary;
$$ LANGUAGE SQL;

SELECT 	salary_changer();
SELECT salary FROM employees ORDER BY salary;

CREATE OR REPLACE FUNCTION get_orders_by_shipping(ship_method int) RETURNS SETOF orders AS $$
DECLARE 
	average numeric;
	maximum numeric;
	middle numeric;
BEGIN 
	SELECT MAX(freight) INTO maximum
	FROM orders
	WHERE ship_via = ship_method
	
	SELECT MAX(freight) INTO maximum
	FROM orders
	WHERE ship_via = ship_method
	
	maximum = maximum - (maximum * 0.3);
	middle = (maxim + average) / 2;
	
	RETURN QUERY
	SELECT *
	FROM orders
	WHERE freight < middle
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION should_increase_salary(
	cur_salary numeric,
	max_salary numeric DEFAULT 80,
	min_salary numeric DEFAULT 30,
	increase_rate numeric DEFAULT 0.2
)	RETURNS bool AS 
$$
DECLARE
	new_salary numeric;
BEGIN 
	IF cur_salary >= max_salary OR cur_salary >= min_salary THEN
		RETURN false;
	END IF;
	
	IF cur_salary < min_salary THEN
		new_salary = cur_salary + (cur_salary * increase_rate);
	END IF;
	
	IF new_salary > max_salary THEN
		RETURN false;
	ELSE
		RETURN true;
	END IF;
END
$$ LANGUAGE plpgsql;

SELECT should_increase_salary(40, 80, 30, 0.2);
SELECT should_increase_salary(79, 81, 80, 0.2);
SELECT should_increase_salary(79, 95, 90, 0.2);

DROP FUNCTION IF EXISTS get_season;
CREATE OR REPLACE FUNCTION get_season(month_number int) RETURNS text AS $$
DECLARE 
	season text;
BEGIN
	IF month_number NOT BETWEEN 1 AND 12 THEN
		RAISE EXCEPTION 'Invalid month. You passed: (%)', month_number USING HINT = 'Allowed from 1 up to 12', ERRCODE = 12882;
	END IF;
	
	IF month_number BETWEEN 3 AND 5 THEN
		season = 'Spring';
	ELSEIF month_number BETWEEN 6 AND 8 THEN
		season = 'Summer';
	ELSEIF month_number BETWEEN 9 AND 11 THEN
		season = 'Autumn';
	ELSE 
		season = 'Winter';
	END IF;
	
	RETURN season;
	
END;
$$ LANGUAGE plpgsql;

SELECT get_season(12);

SELECT get_season(15);

CREATE OR REPLACE FUNCTION get_season_caller(month_number int) returns text AS $$
DECLARE 
	err_ctx text;
	err_msg text;
	err_details text;
	err_code text;
BEGIN
	RETURN get_season(month_number);
EXCEPTION WHEN SQLSTATE '12882' THEN 
	GET STACKED DIAGNOSTICS 
		err_ctx = PG_EXCEPTION_CONTEXT,
		err_msg = MESSAGE_TEXT,
		err_details = PG_EXCEPTION_DETAIL,
		err_code = RETURNED_SQLSTATE;
	RAISE INFO 'My custom handler:';
	RAISE INFO 'Error msg:%', err_msg;
	RAISE INFO 'Error details:%', err_details;
	RAISE INFO 'Error code:%', err_code;
	RAISE INFO 'Error context:%', err_ctx;
	RAISE INFO 'A problem. Nothing special.';
	RETURN NULL;
END;
$$ LANGUAGE plpgsql;

SELECT get_season_caller(15);

CREATE OR REPLACE FUNCTION get_season_caller_2(month_number int) returns text AS $$
DECLARE 
	err_ctx text;
	err_msg text;
	err_details text;
	err_code text;
BEGIN
	RETURN get_season(month_number);
EXCEPTION 
WHEN SQLSTATE '12885' THEN 
	
	RAISE INFO 'My custom handler:';
	RAISE INFO 'Error Name:%', SQLERRM;
	RAISE INFO 'Error details:%', SQLSTATE;
	RAISE INFO 'A problem. Nothing special.';
	RETURN NULL;
WHEN OTHERS THEN
	RAISE INFO 'My custom handler:';
	RAISE INFO 'Error Name:%', SQLERRM;
	RAISE INFO 'Error details:%', SQLSTATE;
	RAISE INFO 'A problem. Nothing special.';
	RETURN NULL;
END;
$$ LANGUAGE plpgsql;

SELECT get_season_caller_2(15);

--hw
DROP FUNCTION should_increase_salary;
create or replace function should_increase_salary(
	cur_salary numeric,
	max_salary numeric DEFAULT 80, 
	min_salary numeric DEFAULT 30,
	increase_rate numeric DEFAULT 0.2
	) returns bool AS $$
declare
	new_salary numeric;
begin
	IF min_salary > max_salary THEN
		RAISE EXCEPTION 'Invalid min/max salary. You passed min salary: (%) You passed max salary: (%)', min_salary, max_salary USING HINT = 'Min salary must be lower than max';--, ERRCODE = 1;
	END IF;
	
	IF min_salary < 0 OR max_salary < 0 THEN
		RAISE EXCEPTION 'Invalid min and max salaies. You passed min salary: (%) You passed max salary: (%)', min_salary, max_salary USING HINT = 'Max and min salaries must be greater than 0';--, ERRCODE = 2;
	END IF;
	
	IF increase_rate < 0.05 THEN
		RAISE EXCEPTION 'Invalid increase rate. You inserted: (%)', increase_rate USING HINT = 'Increase rate can''t be less than 5%';--, ERRCODE = 3;
	END IF;
	
	if cur_salary >= max_salary or cur_salary >= min_salary then 		
		return false;
	end if;
	
	if cur_salary < min_salary then
		new_salary = cur_salary + (cur_salary * increase_rate);
	end if;
	
	if new_salary > max_salary then
		return false;
	else
		return true;
	end if;	
end;
$$ language plpgsql;

SELECT should_increase_salary(79, 10, 80, 0.2);

SELECT should_increase_salary(79, 10, -1, 0.2);

SELECT should_increase_salary(79, 10, 10, 0.04);

CREATE OR REPLACE FUNCTION type_testing(money_val float8) RETURNS void AS
$$
BEGIN
	RAISE NOTICE 'ran %', money_val;
END
$$ LANGUAGE plpgsql;

SELECT type_testing(0.5);
SELECT type_testing(0.5::float4);
SELECT type_testing(1);

CREATE OR REPLACE FUNCTION type_testing2(money_val int) RETURNS void AS
$$
BEGIN
	RAISE NOTICE 'ran %', money_val;
END
$$ LANGUAGE plpgsql;

SELECT type_testing2(1);
SELECT type_testing2(0.5);
SELECT type_testing2(0.5::int);
SELECT type_testing(0.4::int);
SELECT type_testing(CAST(0.5 AS int));

SELECT type_testing2('1.5');
SELECT type_testing2('1.5'::int);
SELECT type_testing2('1.5'::numeric::int);

SELECT type_testing2('3'::int);

SELECT 50! AS big_factorial;
SELECT CAST(50 AS bigint)! AS big_factorial;

SELECT 'abc'|| 1;

SELECT ' 10 ' = 10;

CREATE TABLE perf_test(
	id int, 
	reason text COLLATE "C",
	annotation text COLLATE "C"
);

INSERT INTO perf_test(id, reason, annotation)
SELECT s.id, md5(random()::text), null
FROM generate_series(1, 10000000) AS s(id)
ORDER BY random();

UPDATE perf_test
SET annotation = md5(UPPER(random()::text));


SELECT *
FROM perf_test
WHERE id = 3700000;

EXPLAIN 
SELECT *
FROM perf_test
WHERE id = 3700000;

CREATE INDEX idx_perf_test_id ON perf_test(id);

SELECT *
FROM perf_test
LIMIT 10;

EXPLAIN ANALYZE
SELECT *
FROM perf_test
WHERE reason LIKE 'bc%' AND annotation LIKE 'AB%';

CREATE INDEX idx_perf_test_reason_annotation ON perf_test(reason, annotation);

EXPLAIN 
SELECT *
FROM perf_test
WHERE annotation LIKE 'AB%';

CREATE INDEX idx_perf_test_annotation ON perf_test(annotation);

EXPLAIN
SELECT *
FROM perf_test
WHERE LOWER(annotation) LIKE('ab%');

CREATE INDEX idx_perf_test_annotation_lower ON perf_test(LOWER(annotation));

EXPLAIN
SELECT *
FROM perf_test
WHERE reason LIKE 'bc%';

CREATE EXTENSION pg_trgm;

CREATE INDEX trgm_idx_perf_test_reason ON perf_test USING gin (reason gin_trgm_ops);

CREATE TABLE chess_game (
	white_player text,
	black_player text,
	moves text[],
	final_state text[][]
);

INSERT INTO chess_game
VALUES ('Caruana', 'Nakamura', '{"d4", "d5", "c4", "c6"}',
	   '{{"Ra8","Qe8", "x", "x", "x", "x", "x", "x"},
		{"a7", "x", "x", "x", "x", "x", "x", "x"},
	    {"Kb5", "Bc5", "d5", "x", "x", "x", "x", "x"}}');
		
SELECT *
FROM chess_game;

INSERT INTO chess_game
VALUES ('Caruana', 'Nakamura', ARRAY['d4', 'd5', 'c4', 'c6'],
	   ARRAY[['Ra8','Qe8', 'x', 'x', 'x', 'x', 'x', 'x'],
		['a7', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],
	    ['Kb5', 'Bc5', 'd5', 'x', 'x', 'x', 'x', 'x']]);

SELECT moves[2:3]
FROM chess_game;

SELECT moves[:3]
FROM chess_game;

SELECT moves[2:]
FROM chess_game;

SELECT array_dims(moves), array_length(moves, 1)
FROM chess_game;

SELECT array_dims(final_state), array_length(final_state, 1)
FROM chess_game;

UPDATE chess_game
SET moves = ARRAY['e4', 'd6', 'd4', 'Kf6'];

UPDATE chess_game
SET moves[4] = 'g6';

SELECT *
FROM chess_game
WHERE 'g6' = ANY(moves);

SELECT ARRAY[1, 2, 3, 4] = ARRAY[1, 2, 3, 4];

SELECT ARRAY[1, 2, 4, 3] = ARRAY[1, 2, 3, 4];

SELECT ARRAY[1, 2, 4, 3] > ARRAY[1, 2, 3, 4];
SELECT ARRAY[1, 2, 4, 3] > ARRAY[1, 2, 5, 4];
SELECT ARRAY[1, 2, 3, 4] > ARRAY[1, 2, 3, 4];

SELECT ARRAY [1, 2, 3, 4] @> ARRAY[1, 2];
SELECT ARRAY [1, 2, 3, 4] @> ARRAY[1, 2, 5];

SELECT ARRAY [1, 2] <@ ARRAY [1, 2, 5];
SELECT ARRAY [1, 2, 6] <@ ARRAY [1, 2, 5];

SELECT ARRAY [1, 2, 3, 4] && ARRAY [1, 2];
SELECT ARRAY [1, 2, 3, 4] && ARRAY[5];

SELECT *
FROM chess_game
WHERE moves && ARRAY['d4'];

CREATE FUNCTION filter_even(VARIADIC numbers int[]) RETURNS SETOF int AS $$
BEGIN
	FOR counter IN 1..array_upper(numbers, 1)
	LOOP
		CONTINUE WHEN counter % 2 != 0;
		RETURN NEXT counter;
	END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT *
FROM filter_even(1, 2, 3, 4, 5, 6, 7, 8);

CREATE OR REPLACE FUNCTION filter_even(VARIADIC numbers int[]) RETURNS SETOF int AS $$
DECLARE 
	counter int;
BEGIN
	--FOR counter IN 1..array_upper(numbers, 1)
	FOREACH counter IN ARRAY numbers
	LOOP
		CONTINUE WHEN counter % 2 != 0;
		RETURN NEXT counter;
	END LOOP;
END;
$$ LANGUAGE plpgsql;


--HW
DROP FUNCTION IF EXISTS avg_freight;
CREATE OR REPLACE FUNCTION avg_freight (VARIADIC countries varchar(64)[]) RETURNS float4 AS $$

	SELECT AVG(freight)
	FROM orders
	WHERE ship_country = ANY(countries);

$$ LANGUAGE SQL;

SELECT *
FROM avg_freight('Germany', 'USA', 'Canada');

SELECT *
FROM orders;

CREATE OR REPLACE FUNCTION phone_number_filter(code int, VARIADIC numbers text[]) RETURNS SETOF text AS $$
DECLARE
	cur_val text;
BEGIN
	FOREACH cur_val IN ARRAY numbers
	LOOP
		RAISE NOTICE 'cur val is %', cur_val;
		CONTINUE WHEN cur_val NOT LIKE CONCAT('__(', oper, ')%');
		RETURN NEXT cur_val;
	END LOOP;
END
$$ LANGUAGE plpgsql;

SELECT *
FROM phone_number_filter(903, '+7(903)1901235', '+7(926)8567589', '+7(903)1532476');

